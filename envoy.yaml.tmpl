admin:
  access_log_path: /dev/stdout
  address:
    socket_address:
      protocol: TCP
      # NOTE: Must be accessible to the servo for aggregation
      address: 0.0.0.0
      port_value: ${OPSANI_ENVOY_METRICS_PORT} # OPSANI_ENVOY_METRICS_PORT

static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: ${OPSANI_ENVOY_PROXY_SERVICE_PORT} # OPSANI_ENVOY_PROXY_SERVICE_PORT
    listener_filters:
    - name: envoy.filters.listener.tls_inspector
    - name: envoy.filters.listener.http_inspector

    filter_chains:
    # Match on HTTP ingress traffic
    - filter_chain_match:
        application_protocols:
        - "http/1.1"
        transport_protocol: raw_buffer # NOTE: Matches non-TLS requests
      filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          use_remote_address: true
          route_config:
            virtual_hosts:
            - name: default
              domains: "*"
              routes:
              - match: { prefix: "/" }
                route: { cluster: opsani_proxied_container }
          access_log:
          - name: envoy.access_loggers.file
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
              path: "/dev/stdout"
          http_filters:
          - name: envoy.filters.http.health_check
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.health_check.v3.HealthCheck
              pass_through_mode: true
          - name: envoy.filters.http.grpc_web
          - name: envoy.filters.http.router

    # Match on HTTPS and HTTP/2 ingress traffic
    - filter_chain_match:
        application_protocols:
        - "http/1.1"
        - "h2" # Match HTTP/2 traffic
        transport_protocol: tls
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
          common_tls_context:
            tls_certificates:
            - certificate_chain: { filename: "/etc/certificate_chain.pem" }
              private_key: { filename: "/etc/private_key.pem" }
      filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          use_remote_address: true
          route_config:
            virtual_hosts:
            - name: default
              domains: "*"
              routes:
              - match: { prefix: "/" }
                route: { cluster: opsani_proxied_container }
          access_log:
          - name: envoy.access_loggers.file
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
              path: "/dev/stdout"
          http_filters:
          - name: envoy.filters.http.health_check
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.health_check.v3.HealthCheck
              pass_through_mode: true
          - name: envoy.filters.http.grpc_web
          - name: envoy.filters.http.router
  clusters:
  # TODO: Break this into 2 clusters and switch them based on env var?
  - name: opsani_proxied_container
    connect_timeout: 0.5s
    type: LOGICAL_DNS
    transport_socket_matches:
    - name: "Enable TLS"
      match:
        OPSANI_ENVOY_PROXIED_CONTAINER_TLS_ENABLED: true
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          # sni: remote.example.com # TODO: Becomes an env variable to match on SNI hostname
      #     common_tls_context:
      #       validation_context:
      #         match_subject_alt_names:
      #         - exact: "*.remote.example.com" # TODO: This needs to exactly match the hostname in the upstream SSL certificate
      #         trusted_ca:
      #           filename: /etc/ssl/certs/ca-certificates.crt
    - name: "default"
      match: {}
      transport_socket:
        name: envoy.transport_sockets.raw_buffer
    # NOTE: Uncomment if supporting HTTP/2 as well as HTTPS/1.1
    # If the upstream server does not support HTTP/2 then this will throw a 503
    # http2_protocol_options: {}
    load_assignment:
      cluster_name: opsani_proxied_container
      endpoints:
        - lb_endpoints:
          - endpoint:
              address:
                socket_address:
                  address: ${OPSANI_ENVOY_PROXIED_CONTAINER_ADDR} # OPSANI_ENVOY_PROXIED_CONTAINER_NAME localhost #127.0.0.1
                  port_value: ${OPSANI_ENVOY_PROXIED_CONTAINER_PORT} # OPSANI_ENVOY_PROXIED_CONTAINER_PORT
            metadata:
              filter_metadata:
                envoy.transport_socket_match:
                  # NOTE: This metadata is utilized in the "Enable TLS" stanza above
                  OPSANI_ENVOY_PROXIED_CONTAINER_TLS_ENABLED: ${OPSANI_ENVOY_PROXIED_CONTAINER_TLS_ENABLED}
#     # TODO: We may only need to do this if we want to enable TLS enforcement
#     # TODO: Enabling these next four lines allows GET http -> talk to HTTPS
#     transport_socket:
#       name: envoy.transport_sockets.tls
#       typed_config:
#         "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
#     #     sni: remote.example.com # TODO: Becomes an env variable to match on SNI hostname
#     #     common_tls_context:
#     #       validation_context:
#     #         match_subject_alt_names:
#     #         - exact: "*.remote.example.com" # TODO: This needs to exactly match the hostname in the upstream SSL certificate
#     #         trusted_ca:
#     #           filename: /etc/ssl/certs/ca-certificates.crt

# Avoid warnings about `global_downstream_max_connections`
layered_runtime:
  layers:
    - name: static_layer_0
      static_layer:
        envoy:
          resource_limits:
            listener:
              example_listener_name:
                connection_limit: 10000
        overload:
          global_downstream_max_connections: 50000


# static_resources:
#   listeners:
#   - address:
#       socket_address:
#         address: 0.0.0.0
#         port_value: ${OPSANI_ENVOY_PROXY_SERVICE_PORT} # OPSANI_ENVOY_PROXY_SERVICE_PORT
#     filter_chains:
#     - filters:
#       - name: envoy.filters.network.http_connection_manager
#         typed_config:
#           "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
#           codec_type: AUTO
#           stat_prefix: opsani_proxy_service # Advisory stats prefix
#           route_config:
#             name: local_route
#             virtual_hosts:
#             - name: opsani_proxy_service
#               domains:
#               - "*"
#               routes:
#               - match:
#                   prefix: "/"
#                 route:
#                   cluster: opsani_proxied_container
#           access_log:
#           - name: envoy.access_loggers.file
#             typed_config:
#               "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
#               path: "/dev/stdout"
#           http_filters:
#           - name: envoy.filters.http.health_check
#             typed_config:
#               "@type": type.googleapis.com/envoy.extensions.filters.http.health_check.v3.HealthCheck
#               pass_through_mode: true
#           - name: envoy.filters.http.grpc_web
#           - name: envoy.filters.http.router


# Match on TLS ingress traffic
# - filter_chain_match:
#     transport_protocol: tls # Set by the tls_inspector module
#   transport_socket:
#     name: envoy.transport_sockets.tls
#     typed_config:
#       # TODO: Shouldn't this be Upstream?
#       "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
#       common_tls_context:
#         tls_certificates:
#         - certificate_chain: { filename: "api_example_com_cert.pem" }
#           private_key: { filename: "api_example_com_key.pem" }
#   filters:
#   - name: envoy.filters.network.http_connection_manager
#     typed_config:
#       "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
#       stat_prefix: ingress_http
#       route_config:
#         virtual_hosts:
#         - name: default
#           domains: "*"
#           routes:
#           - match: { prefix: "/" }
#             route: { cluster: opsani_proxied_container }
#       access_log:
#       - name: envoy.access_loggers.file
#         typed_config:
#           "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
#           path: "/dev/stdout"